# python-Apssdc
What is Python?
Python is an interpreted, high-level, general-purpose programming language. Created by Guido van Rossum and first released in 1991, that can be used for a wide variety of applications. It includes data structures, dynamic typing, dynamic binding, and many more features that make it as useful for complex application development



Why python became popular?

Python is used in a variety of purposes, ranging from web development to data science to DevOps. Data science and machine learning becoming more common in many types of companies, and Python becoming a common choice for that purpose.
This is particularly visible in the growth of the p andas package, which is the
fastest-growing Python-related tag on the site. As for which industries are using Python, we found that it is more visited in a few industries, such as electronics, manufacturing, software, government, and especially universities.
 



Who Uses Python?
Python is used by Intel, IBM, NASA, Pixar, JP Morgan Chase, and a number of other major companies. It is one of the four main languages at Google (along with C++, Java, and Go). Google's YouTube is largely written in Python. So are Reddit, Pinterest, and Instagram. The original BitTorrent client was written in Python. It is used as a scripting language to control Maya, the industry standard 3D modeling and animation tool.

Python is used heavily in academic research, particularly in bioinformatics, biology, and mathematics. It is the standard introductory language for many university computer science programs.










Advantages of Python:

 


Applications of Python

●	GUI based desktop applications
○	Image processing and graphic design applications
○	Scientific and computational applications
○	Games
●	Web frameworks and web applications
●	Enterprise and business applications




Literate Programming
Combination of coding and documentation
Literate programming is a programming paradigm introduced by Donald Knuth in which a program is given as an explanation of the program logic in a natural language, such as English, interspersed with snippets of macros and traditional source code, from which a compilable source code can be generated.

Platforms to run Python
IDLE, PyCharm, PyScripter, PyDev, Anaconda, Jupyter etc…

Anaconda
Anaconda is a platform/navigator to run python.
Why should we use Anaconda for Python?
Anaconda is popular because it brings many of the tools used in data science and machine learning. Anaconda contains,popular python libraries that can be used in data
 
science . It also comes with the jupyter notebook and Ipython distribution. So, it saves you from importing numerous libraries separately

Installation Link for Anaconda Software: https://www.anaconda.com/distribution/

Advantages
●	Object oriented programming language.
●	Simple to use.
●	Best for Machine learning and Data Sciences.
●	Huge collection of packages and libraries.



Jupyter Notebook Environment
●	Jupyter is a web - application
●	Jupyter's name is a reference to the three core programming languages supported by Jupyter, which are Julia, Python and R.

Jupyter Notebook
The Jupyter Notebook is an open-source web application that allows you to create and share documents that contain live code, equations, visualizations and narrative text.
Uses include: data cleaning and transformation, numerical simulation, statistical modeling, data visualization, machine learning, and much more.

Advantages
●	Best for data exploration, data preparation, data validation, Productionalization
●	It is a client-server application used for running notebook documents in the browser. Notebook documents are documents able to contain both code and text such as paragraphs, equations and so on

Working with Jupyter Notebook
●	Open Anaconda Navigator
●	Open Jupyter Notebook by clicking on “Launch” option below the Jupyter Notebook application
 

Opening of a new Python Notebook
After launching the Jupyter Notebook
●	Create a folder on the Desktop by entering Desktop folder
●	Click on New (at the right side) >> Folder
●	Give a name(Problem Solving Programing on Python) to that folder
●	Enter that folder New >> Python 3
●	Give a name to that Notebook (today’s date)





Tabs in menu bar
CheckPoint
Jupyter creates a checkpoint file every single time you create an .ipynb file, and then updates the checkpoint file every single time you manually save your progress for the initial.ipynb. The checkpoint file is located within a hidden folder named ipynb_checkpoints.
Save and Checkpoint, Revert to Checkpoint
●	Type a text (your name) in a cell and click on File >> Save and Checkpoint
●	Type a text(your Branch) in the next cell, Click on File >> Revert to Checkpoint, then the cell you saved first will only be displayed
 
Toggle Line Numbers
View >> Toggle Line Numbers, to get the cell numbers

Inserting the cells
Select a cell >> Insert >> Insert Cell Above/Insert Cell Below

Deleting Cell
Select a cell >> Edit >> Delete Cells

Run
To run cell in Jupyter, Go to cell >> Run cells or use shift+enter

Kernel
 A ‘kernel’ is a program that runs and introspects the user’s code. IPython includes a kernel
 for Python code

Shortcuts
 There are two possible ways to interact with Jupyter Notebook
●		Command Mode and
●		Edit Mode.

 Some shortcuts work only on one mode or another while others are common to both
 modes.
 Some shortcuts which are common in both modes are
●		Ctrl + Enter: to run all the selected cells
●		Shift + Enter: run the current cell and move on to the next one
●		Ctrl + s: save notebook

In order to enter Jupyter command mode, we need to press Esc and then any of the following commands
●	H: show all the shortcuts available in Jupyter Notebook
●	Shift + Up/Down Arrow: to select multiple notebook cells at the same time (pressing enter after selecting multiple cells will make all of them run!)
●	A: insert a new cell above
●	B: insert a new cell below
●	X: cut the selected cells
●	Z: undo the deletion of a cell
 
●	Y: change the type of cell to Code
●	M: change the type of cell to Markdown
●		Space: scroll notebook down
●		Shift + Space: scroll notebook up

In order to enter Jupyter edit mode instead, we need to press Enter and successively any of the following commands:
●	Tab: code competition suggestions
●	Ctrl + ]: indent code
●	Ctrl + [: dedent code
●	Ctrl + z: undo
●	Ctrl + y: redo
●	Ctrl + a: select all
●	Ctrl + Home: move cursor to cell start
●	Ctrl + End: move cursor to the end of the cell
●	Ctrl + Left: move cursor one word left
●	Ctrl + Right: move cursor one word right

Markdown Format for Documentation

Markdown cell displays text which can be formatted using markdown language. In order to enter a text which should not be treated as code by Notebook server, it must be first converted as markdown cell either from cell menu or by using keyboard shortcut M while in command mode. The In[] prompt before cell disappears.


The cell will appear like

 

Writing a text
A markdown cell can display header text of 6 sizes, similar to HTML headers. Start the text in markdown cell by # symbol.Use as many # symbols corresponding to level of header you want.

Markdown Syntax

Heading	# Heading1 ## Heading2 ### Heading3
Bold	** Text **
Italic	*Text*
Bold and Italic	***Text***
Normal Text and sublist	*	Text
*	Sublist 1
*	Sublist 2
Sublist Within the sublist	>	1.Ordered list1
>	2.Ordered list2
 
 





Displaying an Image in the Jupyter Notebook
●	Download an image(Jupyter logo) and save it in your local system
●	Write the following code in the markdown cell
OutPut
 
 

Reference for Markdown Commands: https://www.markdownguide.org/cheat-sheet/

Writing Code in Notebook
To Write Code in Jupyter Notebook by using Python language, Make sure that the cell will not be in markdown format. If the cell is in markdown format convert that cell to coding format by using the letter “y”





Python Basics
Using Python language
➢	Print Good morning
➢	Print Hello Python

Here end = “ “ is used to print the two statements in one line. The two statements are separated by space

Python Variables
A variable in programming is used to store the values/data
 
Different types in variable assignments





Keywords in Python:

Keywords are the reserved words in Python. We cannot use a keyword as variable name, function name or any other identifier.

You can always get the list of keywords in your current version by typing the following in the prompt.



Description of Keywords in Python with examples
True, False
 

True and False are truth values in Python. They are the results of comparison operations or logical (Boolean) operations in Python. For example:


1.	
>>> 1 == 1
True
>>> 5 > 3
True
>>> True or False True
>>> 10 <= 1
False
>>> 3 > 7
False
>>> True and False False
2.	
3.	
4.	
5.	
6.	
7.	
8.	
9.	
10.	
11.	
12.	
13.	

Here we can see that the first three statements are true so the interpreter returns True and returns False for the remaining three statements. True and False in python is same as 1 and 0. This can be justified with the following example:


1. >>> True == 1
2.	True
>>> False == 0 True
>>> True + True
2
3.	
4.	
5.	
6.	

None

None is a special constant in Python that represents the absence of a value or a null value.

It is an object of its own datatype, the NoneType. We cannot create multiple None objects but can assign it to variables. These variables will be equal to one another.

We must take special care that None does not imply False, 0 or any empty list, dictionary, string etc. For example:

1. >>> None == 0	
 
 2. 	False
 3. 	>>> None == []
False
>>> None == False False
>>> x = None
>>> y = None
>>> x == y
 4. 	
 5. 	
 6. 	
 7. 	
 8. 	
 9. 	
10.True

Void functions that do not return anything will return a None object automatically. None is also returned by functions in which the program flow does not encounter a return statement. For example:


1.	
def a_void_function(): a = 1
b = 2
c = a + b

x = a_void_function() print(x)
2.	
3.	
4.	
5.	
6.	
7.	
8.	

Output


 None



This program has a function that does not return a value, although it does some operations inside. So when we print x, we get None which is returned automatically (implicitly). Similarly, here is another example:


1.	def improper_return_function(a):
 2. 	if (a % 2) == 0:
 3. 	return True
 4. 	
 5. 	x = improper_return_function(3)
 6. 	print(x)
 
Output

 None



Although this function has a return statement, it is not reached in every case. The function will return True only when the input is even.

If we give the function an odd number, None is returned implicitly.

and, or , not

and, or, not are the logical operators in Python. and will result into True only if both the operands are True. The truth table for and is given below:


A	B	A and B
True	True	True
True	False	False
False	True	False
False	False	False
or will result into True if any of the operands is True. The truth table for or is given below:


 
True	True	True
True	False	True
False	True	True
False	False	False
not operator is used to invert the truth value. The truth table for not is given below:


A	not A
True	False
False	True
some example of their usage are given below


1. >>> True and False
2.	False
>>> True or False True
>>> not False
True
3.	
4.	
5.	
6.	

as

as is used to create an alias while importing a module. It means giving a different name (user-defined) to a module while importing it.
 
As for example, Python has a standard module called math. Suppose we want to calculate what cosine pi is using an alias. We can do it as follows using as:


Here we imported the math module by giving it the name myAlias. Now we can refer to the math module with this name. Using this name we calculated cos(pi) and got -1.0 as the answer.

assert

assert is used for debugging purposes.

While programming, sometimes we wish to know the internal state or check if our assumptions are true. assert helps us do this and find bugs more conveniently. assert is followed by a condition.

If the condition is true, nothing happens. But if the condition is false, AssertionError is raised. For example:


1. >>> a = 4
2.	>>> assert a < 5
>>> assert a > 5
Traceback (most recent call last): File "<string>", line 301, in runcode
File "<interactive input>", line 1, in <module>
AssertionError
3.	
4.	
5.	
6.	
7.	

For our better understanding, we can also provide a message to be printed with the
AssertionError.


1. >>> a = 4
2.	>>> assert a > 5, "The value of a is too small" Traceback (most recent call last):
File "<string>", line 301, in runcode
File "<interactive input>", line 1, in <module> AssertionError: The value of a is too small
3.	
4.	
5.	
6.	
 
At this point we can note that,

1.	assert condition, message	

is equivalent to,



break, continue

break and continue are used inside for and while loops to alter their normal behavior.

break will end the smallest loop it is in and control flows to the statement immediately below the loop. continue causes to end the current iteration of the loop, but not the whole loop.

This can be illustrated with the following two examples:



Output

 1
 2
 3
 4



Here, the for loop intends to print numbers from 1 to 10. But the if condition is met when
i is equal to 5 and we break from the loop. Thus, only the range 1 to 4 is printed.


 
4.	print(i)	

Output

 1
 2
 3
 4
 6
 7
 8
 9
 10



Here we use continue for the same program. So, when the condition is met, that iteration is skipped. But we do not exit the loop. Hence, all the values except 5 is printed out.

Learn more about Python break and continue statement.

class

class is used to define a new user-defined class in Python.

Class is a collection of related attributes and methods that try to represent a real world situation. This idea of putting data and functions together in a class is central to the concept of object-oriented programming (OOP).

Classes can be defined anywhere in a program. But it is a good practice to define a single class in a module. Following is a sample usage:


1. class ExampleClass:
2.	def function1(parameters):
…
def function2(parameters):
…
3.	
4.	
5.	

Learn more about Python Objects and Class.
 
def

def is used to define a user-defined function.

Function is a block of related statements, which together does some specific task. It helps us organize code into manageable chunks and also to do some repetitive task.

The usage of def is shown below:



Learn more about Python functions.

del

del is used to delete the reference to an object. Everything is object in Python. We can delete a variable reference using del


1. >>> a = b = 5
2.	>>> del a
>>> a
Traceback (most recent call last): File "<string>", line 301, in runcode
File "<interactive input>", line 1, in <module> NameError: name 'a' is not defined
>>> b
5
3.	
4.	
5.	
6.	
7.	
8.	
9.	

Here we can see that the reference of the variable a was deleted. So, it is no longer defined. But b still exists.

del is also used to delete items from a list or a dictionary:


 1. 	
>>> a = ['x','y','z']
>>> del a[1]
>>> a
 2. 	
 3. 	
 4. 	
 
5. ['x', 'z']

if, else, elif

if, else, elif are used for conditional branching or decision making.

When we want to test some condition and execute a block only if the condition is true, then we use if and elif. elif is short for else if. else is the block which is executed if the condition is false. This will be clear with the following example:


1. def if_example(a):
2.	if a == 1: print('One')
elif a == 2: print('Two')
else:
print('Something else')

if_example(2) if_example(4) if_example(1)
3.	
4.	
5.	
6.	
7.	
8.	
9.	
10.	
11.	

Output

 Two
 Something else
 One



Here, the function checks the input number and prints the result if it is 1 or 2. Any input other than this will cause the else part of the code to execute.

Learn more about Python if and if...else Statement.

except, raise, try

except, raise, try are used with exceptions in Python.
 
Exceptions are basically errors that suggests something went wrong while executing our program. IOError, ValueError, ZeroDivisionError, ImportError, NameError, TypeError etc. are few examples of exception in Python. try...except blocks are used to catch exceptions in Python.

We can raise an exception explicitly with the raise keyword. Following is an example:


1. def reciprocal(num):
2.	try:
r = 1/num except:
print('Exception caught') return
return r

print(reciprocal(10)) print(reciprocal(0))
3.	
4.	
5.	
6.	
7.	
8.	
9.	
10.	

Output

0.1
 Exception caught
 None

Here, the function reciprocal() returns the reciprocal of the input number. When we enter 10, we get the normal output of 0.1. But when we input 0, a
ZeroDivisionError is raised automatically.

This is caught by our try…except block and we return None. We could have also raised the ZeroDivisionError explicitly by checking the input and handled it elsewhere as follows:


finally
 

finally is used with try…except block to close up resources or file streams.

Using finally ensures that the block of code inside it gets executed even if there is an unhandled exception. For example:


 1. 	try:
Try-block
except exception1: Exception1-block except exception2:
Exception2-block else:
Else-block
finally:
 2. 	
 3. 	
 4. 	
 5. 	
 6. 	
 7. 	
 8. 	
 9. 	
10. Finally-block

Here if there is an exception in the Try-block, it is handled in the except or else block. But no matter in what order the execution flows, we can rest assured that the Finally-block is executed even if there is an error. This is useful in cleaning up the resources.

Learn more about exception handling in Python programming.

for

for is used for looping. Generally we use for when we know the number of times we want to loop.

In Python we can use it with any type of sequence like a list or a string. Here is an example in which for is used to traverse through a list of names:


Output

 Hello John
 Hello Monica
 Hello Steven
 
 Hello Robin



Learn more about Python for loop.

from, import

import keyword is used to import modules into the current namespace. from…import is used to import specific attributes or functions into the current namespace. For example:

1. import math	

will import the math module. Now we can use the cos() function inside it as math.cos(). But if we wanted to import just the cos() function, this can done using from as

1. from math import cos	

now we can use the function simply as cos(), no need to write math.cos(). Learn more on Python modules and import statement.
global

global is used to declare that a variable inside the function is global (outside the function).

If we need to read the value of a global variable, it is not necessary to define it as global. This is understood.

If we need to modify the value of a global variable inside a function, then we must declare it with global. Otherwise a local variable with that name is created.

Following example will help us clarify this.


 
4. def write1():
5.	global globvar globvar = 5
def write2(): globvar = 15

read1() write1() read1() write2() read1()
6.	
7.	
8.	
9.	
10.	
11.	
12.	
13.	
14.	

Output

 10
 5
 5



Here, the read1() function is just reading the value of globvar. So, we do not need to declare it as global. But the write1() function is modifying the value, so we need to declare the variable as global.

We can see in our output that the modification did take place (10 is changed to 5). The
write2() also tries to modify this value. But we have not declared it as global.

Hence, a new local variable globvar is created which is not visible outside this function. Although we modify this local variable to 15, the global variable remains unchanged. This is clearly visible in our output.

in

in is used to test if a sequence (list, tuple, string etc.) contains a value. It returns True if the value is present, else it returns False. For example:

 
5. False

The secondary use of in is to traverse through a sequence in a for loop.



Output

 h
 e
 l
 l
 o



is

is is used in Python for testing object identity. While the == operator is used to test if two variables are equal or not, is is used to test if the two variables refer to the same object.

It returns True if the objects are identical and False if not.


1. >>> True is True
2.	True
>>> False is False True
>>> None is None
True
3.	
4.	
5.	
6.	

We know that there is only one instance of True, False and None in Python, so they are identical.


1. >>> [] == []
2.	True
>>> [] is []
False
>>> {} == {}
True
>>> {} is {}
3.	
4.	
5.	
6.	
7.	
 
8. False

An empty list or dictionary is equal to another empty one. But they are not identical objects as they are located separately in memory. This is because list and dictionary are mutable (value can be changed).


1. >>> '' == ''
2.	True
>>> '' is ''
True
>>> () == ()
True
>>> () is ()
True
3.	
4.	
5.	
6.	
7.	
8.	

Unlike list and dictionary, string and tuple are immutable (value cannot be altered once defined). Hence, two equal string or tuple are identical as well. They refer to the same memory location.

lambda

lambda is used to create an anonymous function (function with no name). It is an inline function that does not contain a return statement. It consists of an expression that is evaluated and returned. For example:


Output

 2
 4
 6
 8
 10
 
Here, we have created an inline function that doubles the value, using the lambda
statement. We used this to double the values in a list containing 1 to 5. Learn more about Python lamda function.
nonlocal

The use of nonlocal keyword is very much similar to the global keyword. nonlocal is used to declare that a variable inside a nested function (function inside a function) is not local to it, meaning it lies in the outer inclosing function. If we need to modify the value of a non-local variable inside a nested function, then we must declare it with nonlocal.
Otherwise a local variable with that name is created inside the nested function. Following example will help us clarify this.


1. def outer_function():
2.	a = 5
def inner_function(): nonlocal a
a = 10
print("Inner function: ",a) inner_function() print("Outer function: ",a)

outer_function()
3.	
4.	
5.	
6.	
7.	
8.	
9.	
10.	

Output

 Inner function:	10
 Outer function:	10



Here, the inner_function() is nested within the outer_function.

The variable a is in the outer_function(). So, if we want to modify it in the inner_function(), we must declare it as nonlocal. Notice that a is not a global variable.

Hence, we see from the output that the variable was successfully modified inside the nested inner_function(). The result of not using the nonlocal keyword is as follows:
 
1. def outer_function():
2.	a = 5
def inner_function(): a = 10
print("Inner function: ",a) inner_function() print("Outer function: ",a)

outer_function()
3.	
4.	
5.	
6.	
7.	
8.	
9.	

Output

 Inner function:	10
 Outer function:	5



Here, we do not declare that the variable a inside the nested function is nonlocal. Hence, a new local variable with the same name is created, but the non-local a is not modified as seen in our output.

pass

pass is a null statement in Python. Nothing happens when it is executed. It is used as a placeholder.

Suppose we have a function that is not implemented yet, but we want to implement it in the future. Simply writing,

1. def function(args):	

in the middle of a program will give us IndentationError. Instead of this, we construct a blank body with the pass statement.



We can do the same thing in an empty class as well.

1.	class example:	
 
2.	pass

return

return statement is used inside a function to exit it and return a value.

If we do not return a value explicitly, None is returned automatically. This is verified with the following example.


1. def func_return():
2.	a = 10
return a

def no_return(): a = 10

print(func_return()) print(no_return())
3.	
4.	
5.	
6.	
7.	
8.	
9.	

Output

 10
 None



while

while is used for looping in Python.

The statements inside a while loop continue to execute until the condition for the while loop evaluates to False or a break statement is encountered. Following program illustrates this.


 1. 	i = 5 while(i):
print(i)
i = i – 1
 2. 	
 3. 	
 4. 	
 
Output

 5
 4
 3
 2
 1



Note that 0 is equal to False.

Learn more about Python while loop.

with

with statement is used to wrap the execution of a block of code within methods defined by the context manager.

Context manager is a class that implements enter and exit methods. Use of with statement ensures that the exit method is called at the end of the nested block. This concept is similar to the use of try…finally block. Here, is an example.


This example writes the text Hello world! to the file example.txt. File objects have    enter	
and    exit 	method defined within them, so they act as their own context manager.

First the enter method is called, then the code within with statement is executed and finally the exit method is called. exit  method is called even if there is an error. It basically closes the file stream.

yield

yield is used inside a function like a return statement. But yield returns a generator.
 
Generator is an iterator that generates one item at a time. A large list of value will take up a lot of memory. Generators are useful in this situation as it generates only one value at a time instead of storing all the values in memory. For example,

1. >>> g = (2**x for x in range(100))	

will create a generator g which generates powers of 2 up to the number two raised to the power 99. We can generate the numbers using the next() function as shown below.


1. >>> next(g)
2.	1
>>> next(g) 2
>>> next(g) 4
>>> next(g) 8
>>> next(g)
16
3.	
4.	
5.	
6.	
7.	
8.	
9.	
10.	

And so on… This type of generator is returned by the yield statement from a function. Here is an example.


1. def generator():
2.	for i in range(6): yield i*i

g = generator() for i in g:
print(i)
3.	
4.	
5.	
6.	
7.	

Output

 0
 1
 4
 9
 16
 25
 
Here, the function generator() returns a generator that generates square of numbers from 0 to 5. This is printed in the for loop.



Data Types and Conversion

●	int – holds signed integers of non-limited length.
●	float - holds floating precision numbers and it’s accurate upto 15 decimal places.
●	string - holds a sequence of characters
In Python we need not to declare data type. We can simply just assign values in a variable. But if we want to see the type of value is it holding right now, we can use type().




Type of f1 is float, but here by using int(f1), f1 is converted into integer value


by using str(f1), int(f1) is converted into string type


by using float(f1), str(int((f1))) is converted into string type
 
What are the operators in python?

Operators are special symbols in Python that carry out arithmetic or logical computation. The value that the operator operates on is called the operand.

For example:



Here, + is the operator that performs addition. 2 and 3 are the operands and 5 is the output of the operation.

1.	Arithmetic operators:

Arithmetic operators are used to perform mathematical operations like addition, subtraction, multiplication etc.

 

/	Divide left operand by the right one (always results into float)	
x / y

%	
Modulus - remainder of the division of left operand by the right	x	%	y (remainder of x/y)

//	Floor division - division that results into whole number adjusted to the left in the number line	
x // y

**	
Exponent - left operand raised to the power of right	x**y (x to the power y)
 
Example: Arithmetic operators in Python

1. 	x = 15
y = 4

# Output: x + y = 19 print('x + y =',x+y)

# Output: x - y = 11 print('x - y =',x-y)

# Output: x * y = 60 print('x * y =',x*y)

# Output: x / y = 3.75 print('x / y =',x/y)

# Output: x // y = 3 print('x // y =',x//y)

# Output: x ** y = 50625 print('x ** y =',x**y)
2. 	
3. 	
4. 	
5. 	
6. 	
7. 	
8. 	
9. 	
10.	
11.	
12.	
13.	
14.	
15.	
16.	
17.	
18.	
19.	
20.	
When you run the program, the output will be:

x + y = 19 x - y = 11  x * y = 60  x / y = 3.75 x // y = 3
x ** y = 50625
 
2.	Comparison operators:

Comparison operators are used to compare values. It either returns True or False
according to the condition.


Operator	Meaning		Example

>	Greater than - True if left operand is greater than the right	
x > y
<	Less than - True if left operand is less than the right	x < y
==	Equal to - True if both operands are equal	x == y
!=	Not equal to - True if operands are not equal	x != y

>=	Greater than or equal to - True if left operand is greater than or equal to the right	
x >= y

<=	Less than or equal to - True if left operand is less than or equal to the right	
x <= y
 
Example : Comparison operators in Python

1. 	x = 10
y = 12

# Output: x > y is False print('x > y is',x>y)

# Output: x < y is True print('x < y is',x<y)

# Output: x == y is False print('x == y is',x==y)

# Output: x != y is True print('x != y is',x!=y)

# Output: x >= y is False print('x >= y is',x>=y)

# Output: x <= y is True print('x <= y is',x<=y)
2. 	
3. 	
4. 	
5. 	
6. 	
7. 	
8. 	
9. 	
10.	
11.	
12.	
13.	
14.	
15.	
16.	
17.	
18.	
19.	
20.	
3.	Logical operators:

Logical operators are the and, or, not operators.

 
Example: Logical Operators in Python

1.	x = True
2.	y = False
3.	
# Output: x and y is False print('x and y is',x and y)

# Output: x or y is True print('x or y is',x or y)

# Output: not x is False print('not x is',not x)
4.	
5.	
6.	
7.	
8.	
9.	
10.	
11.	
Here is the truth table for these operators.

4.	Bitwise operators:

Bitwise operators act on operands as if they were string of binary digits. It operates bit by bit, hence the name.

For example, 2 is 10 in binary and 7 is 111.

In the table below: Let x = 10 (0000 1010 in binary) and y = 4 (0000 0100 in binary)


 
^	Bitwise XOR	x ^ y = 14 (0000 1110)
>>	Bitwise right shift	x>> 2 = 2 (0000 0010)
<<	Bitwise left shift	x<< 2 = 40 (0010 1000)
5.	Assignment operators:

Assignment operators are used in Python to assign values to variables.

a = 5 is a simple assignment operator that assigns the value 5 on the right to the variable
a on the left.

There are various compound operators in Python like a += 5 that adds to the variable and later assigns the same. It is equivalent to a = a + 5.

 
%=	x %= 5	x = x % 5
//=	x //= 5	x = x // 5
**=	x **= 5	x = x ** 5
&=	x &= 5	x = x & 5
|=	x |= 5	x = x | 5
^=	x ^= 5	x = x ^ 5
>>=	x >>= 5	x = x >> 5
<<=	x <<= 5	x = x << 5
6.	Identity operators:

is and is not are the identity operators in Python. They are used to check if two values (or variables) are located on the same part of the memory. Two variables that are equal does not imply that they are identical.

 

is not	True if the operands are not identical (do not refer to the same object)	x is not True
Example: Identity operators in Python

1. 	x1 = 5
y1 = 5
x2 = 'Hello' y2 = 'Hello' x3 = [1,2,3]
y3 = [1,2,3]

# Output: False print(x1 is not y1)

# Output: True print(x2 is y2)

# Output: False print(x3 is y3)
2. 	
3. 	
4. 	
5. 	
6. 	
7. 	
8. 	
9. 	
10.	
11.	
12.	
13.	
14.	
15.	
Here, we see that x1 and y1 are integers of same values, so they are equal as well as identical. Same is the case with x2 and y2 (strings).But x3 and y3 are list. They are equal but not identical. It is because interpreter locates them separately in memory although they are equal.

7.	Membership operators:

in and not in are the membership operators in Python. They are used to test whether a value or variable is found in a sequence (string, list, tuple, set and dictionary).

In a dictionary we can only test for presence of key, not the value.



 
in	True if value/variable is found in the sequence	5 in x
not in	True if value/variable is not found in the sequence	5 not in x
 
Example: Membership operators in Python

1. x = 'Hello world'
2. y = {1:'a',2:'b'}
3.	
# Output: True print('H' in x)

# Output: True print('hello' not in x)

# Output: True print(1 in y)

# Output: False print('a' in y)
4.	
5.	
6.	
7.	
8.	
9.	
10.	
11.	
12.	
13.	
14.	
Here, 'H' is in x but 'hello' is not present in x (remember, Python is case sensitive). Similary, 1 is key and 'a' is the value in dictionary y. Hence, 'a' in y returns False.
 
Coding to do Arithmetic Operations in Python



Indentation
Python relies on indentation, using whitespace, to define scope in the code. Other programming languages often use curly-brackets for this purpose. If there is no proper indentation, we will get an error.


 
Reading the input Dynamically
For this purpose, Python provides the function input(). It always returns a string.
Methods to take different types of inputs
●	String as input: intput()
This will take both numbers and strings as input


●	Number as input: int(input())
This will accept numbers only as input. If you give string as input, you will get an error




Conditional Statements
Decision making is depending on the condition whether the condition is satisfied or not. In Python we use “:” at the end of the condition
●	if Statement
●	If...else Statement
●	If..elif...else
●	Nested if Statement
 
Example on Conditional Statements
●	Check if the given number is a positive or negative or zero and display a message accordingly


Tasks :

●	Check the given year is a Leap year or not
●	Check if the number exist in a given range (inputs: number(n), range(lower number and upper number)
●	Check the number of digits in a given number
●	Check if the given number is a factor of 1000
●	Calculate the square root of a given number
●	Calculate the number of nano degrees in a given year(Consider the Leap year also)
Iterations
If we need to execute a condition for several number of times, then we need to use looping control statements.

For loop:
The for loop is used to iterate over a sequence(that is either a lists, tuples, dictionaries, sets or a strings).
Syntax: for each in sequence :
Body of for
 

Here ‘ each ‘ is a variable that takes the value inside the sequence. The loop will continue until it reaches the ending value in the sequence.







Example
●	Print 1 to 10 numbers using for loop.



●	Program to print the pyramid pattern in python using for loop.
 

 

●	Read the given string that contains alphanumeric values. Print all even number, all odd numbers and alphabets separately.
 

 

Tasks
●	Print alternate numbers from 1 to 10 using for loop.
●	Print the given string letter by letter using for loop. (Looping on a String)
●	Iterate the integers from 1 to 50, for multiples of 3 print “Fizz” and for multiples of 5 print “Buzz” and for multiples of both 3 and 5 print “FizzBuzz”.
●	Program to print the multiplication table from range between 10 to 20	(Ex: 3 x 10 = 30….)

While Loop:
While loop is used to iterate the statement as long as the condition is satisfied.


Syntax: while condition :
Body of while
 

Examples
●	Print n Natural Numbers using while loop


Task
●	Program print n number of iterations using while loop with if statement.


Functions
A function is a set of statements that take inputs, do some specific computation and produces output. The idea is to put some commonly or repeatedly done task together and make a function, so that instead of writing the same code again and again for different inputs, we can call the function.

Python provides built-in functions like int(), input(), float(), print(), abs(), chr(), etc. but we can also create your own functions. These functions are called user-defined functions.

Parameters
A parameter is a variable used to define a particular value during a function definition.

Arguments
An argument is a value passed to a function at the time of function calling.
 

Examples on Functions

●	Function	to	find	the	factorial	of	a	given	number




Here we define a function called factorial and pass a parameter “n” . At the time of calling the function, we pass the argument “5”, and return the factorial of 5 as fact

Types of functions in Python
●	Without arguments & without return values
●	Without arguments & with return Value
●	With arguments & without return values
●	With arguments & return values



➢	Without arguments & without return value
 
 





●	Without arguments and with return Value


●	With arguments & without return value


●	With arguments & return value
 
 

Recursive Functions
When a function call itself is known as recursive functions. Advantages of recursive function
●	Recursive functions make the code simple.
●	A complex task can be broken down into sub tasks by using recursion.

Example on Recursive function

●	Write a function to find the factorial of a given number without recursion




●	Write a function to find the factorial of a given number with recursion
 
 


Tasks
●	Function to print all numbers divisible by 6 and not a factor of 100 in a given range(lb, ub) inclusive
●	Function to find the average of cubes of all the even numbers in a given range(lb, ub) inclusive
●	Function to generate the list of factors for a given number
●	Function to calculate the factorial of a given number
●	Function to check if a given number is Prime by using recursive function
●	Function to calculate the average first N Prime numbers	by using recursive function
●	Function to generate all Perfect numbers in a given range	by using recursive function
●	Function to calculate the average of all factorials in a given range
●	Function to generate N odd armstrong numbers
●	Function to generate Multiplication table for a number in a given range
○	10 in the range(100, 102) inclusive
○	10 x 100 = 1000
○	10 x 101 = 1010
○	10 x 102 = 1020
String Slicing
The Python string data type is a sequence of one or more individual characters that could consist of letters, numbers, whitespace characters, or symbols.
 
We access strings through indexing, slicing them through their character sequences, and go over some counting and character location methods.
How Strings are Indexed?
Each of a string’s characters correspond to an index number, starting with the index number 0. In this spaces also be indexed.

Example
Index of HELLO WORLD!
H	E	L	L	O		W	O	R	L	D	!
0	1	2	3	4	5	6	7	8	9	10	11
Accessing Characters by Positive Index Number
By referencing index numbers, we can isolate one of the characters in a string. We do this by putting the index numbers in square brackets. Let’s declare a string, print it, and call the index number in square brackets



Accessing Characters by Negative Index Number
If we have a long string and we want to pinpoint an item towards the end, we can also count backwards from the end of the string, starting at the index number -1.
For the same string HELLO WORLD! the negative index breakdown looks like

H	E	L	L	0		W	O	R	L	D	!
-12	-11	-10	-9	-8	-7	-6	-5	-4	-3	-2	-1
 
 


Slicing Strings
We can also call out a range of characters from the string. Say we would like to just print the word “HELLO” can do so by creating a slice, which is a sequence of characters within an original string. With slices, we can call multiple character values by creating a range of index numbers separated by a colon [x:y]:


Here first index number is where the slice starts (inclusive), and the second index number is where the slice ends (exclusive). I.e, the index value of o is 4, but we gave range as [0:5] to print “Hello”

Example on String Slicing

String: s1= “Python”
 
 

Methods in String Slicing
 


Split() Method

split() method returns a list of strings after breaking the given string by the specified separator.

We will write split() method as - string.split()
In general split(), splits the string based on space then it will be converted as list. So, here HELLO WORLD! Was displayed in [ ]

If you specify specific separator, then it will be separated based on the separator. The separator must be given in a string format

Here we gave a separator ! in string like “!”.

join() Method

The join() method is a string method and returns a string in which the elements of sequence have been joined by str separator.
 

 

Note: Python strings are case sensitive

islower(), is upper Methods

In Python, islower and isupper() is a built-in method used for string handling. islower(): To check all characters in a string is lowercase alphabets or not
isupper():	To	check all characters in a string
is	uppercase	alphabets or not







lower(), upper() Methods

lower(): To change all the characters of a string to lowercase upper(): To change all the characters of a string to uppercase
 
 

count() Method

count(): To find how many times a specific character repeated in a string



Task
●	Take a string “Problem Solving Using Python”
○	Find the length of the string
○	Change the string to lowercase
○	Print the string in reverse order
○	Split the string
○	Print the string without spaces
○	Find how many times “s” is repeated in a given string
●	Take a string “python programming by python platforms”
○	Find how many times “python” is repeated
 



Data Structures
Data Structures are used to store the collection of data together. Python has four types of inbuilt data structures.
Lists:
Lists in Python Data Structures are used to store the collection of multiple data. Lists are ordered and immutable or changeable. Lists allows duplicate elements or values. Lists are represented as square brackets. Ex: list = [ ]


Here original list1 is changed. So called Lists are immutable. List can have another list, follow the given example
List1 = [ 10, 20, [ 1, 2, 3 ], [ “ a'', “b'' ], 30 ]
Indexes →	0	1	2	3	4

10	20	[ 1, 2, 3 ]	[ ‘ a ‘ , ‘ b ‘ ]	30
 

 

List Methods
L1 = [ 1, 2, 3 ]	L2 = [ 10, 20, 30 ]	L3 = [ 19, 12, 25, 12, 28, 12 ]
List Methods	Description of Methods
append( )	Adds an item at the end of the list Example: L1.append( 22 )
Result:	L1 = [ 1, 2, 3, 22 ]
extend( )	Adds one entire list into another list. Example: L1.extend( L2 )
Result:	L1 = [ 1, 2, 3, 10, 20, 30 ]
copy( )	Returns the copy of list
Example: List1 = L1.copy( ) Result:	List1 = [ 1, 2, 3 ]
count( )	Returns the count of elements in list Example: L3.count( 12 )
Result:	3
index( )	Returns the index position of particular value in the list Example: L2.index( 30 )
Result:	2
insert( )	Adds an item at a particular position in the list Example: L1.insert( 2, “Python” )
Result:	L1 = [ 1, 2, “Python”, 3 ]
pop( )	Removes an item at the end of the list Example: L1.pop( )
Result:	L1 = [ 1, 2 ]
remove( )	Removes an item at a particular position of the list Example: L2.remove( 20 )
Result:	L2 = [ 10, 30 ]
 
reverse( )	Reverse the items in list Example: L3.reverse( )
Result:	L3 = [ 12, 28, 12, 25, 12, 19 ]
sort( )	Sorts the items in ascending order Example: L3.sort( )
Result:	L3 = [ 12, 12, 12, 19, 25, 28 ]
clear( )	Removes all elements in the list
Example: L1.clear( )	Result: [ ]
Examples
●	Given list contains all electronic items. If you find any item which is not related to electronics then remove it using slicing method.


●	Find the length of the given list. Also print the minimum and maximum values in the list.

Tasks
●	Take a list of elements and add that list into another empty list
●	Sort the list of elements in ascending order and descending order.
●	Given a two list of equal size create a set such that it shows the element from both lists in the pair.
●	Write a python program to print the sum and average of elements in the list.
 


Tuples:
Tuples are similar to lists which is used to store the collection of multiple data. Tuples are ordered and mutable or unchangeable. Tuple is represented as parentheses “ ( ) “. Ex: tuple = ( )


Tuple Methods
●	index( ) : Returns the index position of particular value in tuple.
●	count( ) : Returns the count of items in the tuple.

Example
●	Program to convert the given tuple into string.

Tasks
●	Python program to reverse the given elements in tuple.
●	Python program to print names in tuples using iterations
 

Dictionary:
Dictionaries in Python are used to store the collection of data. Dictionaries are unordered and changeable. It is represented as flower brackets. Ex: dict = { }
●	Dictionaries have a pair of “keys” and “values” separated by “ : “.
Here, “key1, key2” act as keys in dict1 and “200, Python” act as values in the dictionary “dict1”.

●	Comparison between Lists and Dictionaries.

In lists, we can get a value of list using index of that particular value. But in dictionaries, we can get any value using its key. Here Keys are act as an index of the Values.
●	“Key” is the unique identifier for a “value”.
●	“Value” is data that can be accessed with a “key”.

Dictionary Methods
dict1 = { ' k1 ' : 200, ' k2 ' : 300, ' k3 ' : 400 }
Dictionary Methods	Description
copy( )	Returns the copy of dictionary Example: dict2 = dict1.copy( )
Result:	dict2 = { ' k1 ' : 200, ' k2 ' : 300, ' k3 ' : 400 }
fromkeys( )	Returns specified keys and values
Example: x = (‘key1’ , ‘key2’)	y = 0
 
	newDict = dict.fromkeys(x, y) Result:	newDict = [ ‘key1’ : 0, ‘key2’ = 0 ]
get( )	Gets the value using particular key. Example: dict1.get( ‘ k1 ’ )
Result:	200
items( )	Returns the list containing tuple for each pair of key and value Example: dict1.items( )
Result:	dict_items ([('k1', 200), ('k2', 300), ('k3', 400)])
keys( )	Similar to get( ) method. Example: dict1.keys( )
Result:	dict_keys(['k1', 'k2', 'k3'])
values( )	Returns the list containing tuple for each pair of key and value Example: dict1.items( )
Result:	dict_items ([('k1', 200), ('k2', 300), ('k3', 400)])
pop( )	Removes the value using specified key Example: dict1.pop( ‘ k1 ‘ )
popitem( )	Removes the key and value at the end of the dictionary Example: dict1.popitem( )
Result:	dict1 = { ' k1 ' : 200, ' k2 ' : 300 }
setdefault( )	If key does not exist, this method insert key. Returns the value of particular key
update( )	Updates the values of specified key
Example: dict1.update({'color' : 'green'})
Result:	dict1 = {'k1': 200, 'k2': 300, 'k3': 400, 'color': 'green'}
clear( )	Removes all items in the dictionary
Example: dict1.clear( )	Result:	{ }
Example
●	Take three dictionaries and concatenate all three into one new dictionary
 
 

●	Build a Contact Application in an android phone. Add a number in your contact application

●	Search for the number and if number is exist, print name and number otherwise, print number does not exist.
 

 

●	Update your contacts in contact application.


●	A dictionary contains students data( keys → S.No, values → list of name , age ). Now add a new student data and delete one old student data. Print result in the format of “S.No : [ name , age ] “

 
Sets:
Sets are used to store the collection of data in python. It is unordered and unindexed. Sets contain unique values. It is also represented as curly brackets. Ex: Set = { } or Set( )


Methods in Sets
●	add( ): Adds an element at the end of the Set
●	copy( ): Returns copy of the Set
●	clear( ): removes all the elements in the Set
●	pop( ): Removes the element from the end of the Set
●	remove( ): Removes specified element
●	update( ): Adds an entire set into another set.

●	difference( ): Remove the common elements in two sets and Returns the unique elements in the first set.
 
 
●	difference_update( ): Returns the new updated set after make a difference between the two sets.

●	intersection( ): Returns the set that is the intersection of two other sets.

●	intersection_update( ): Removes the elements in one set which is not there in another and Returns updated set.
●	discard( ): Removes specified element.
 

●	isdisjoint( ): Returns True, whether two sets are intersection.
 
 

●	issubset( ): Returns True, whether two sets .
●	issuperset( ): Similar to issubset. It will check all the elements in “values2” is present in “values1”, then it returns True.
●	symmetric_difference( ): Returns a set of elements that are present in either one set or another set
●	symmetric_difference_update ( ): Returns newly updated set with symmetric difference between the two sets.
 
 





●	union( ): Returns a set with elements present in both sets.


Example
●	Take two sets and print the result using methods like Union, Difference and so on.
 
